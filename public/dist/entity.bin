POG_LIMB_V6.5
ID:entity
SOURCE_MAP:INTERNAL
---
import { NeuralLimb } from './NeuralLimb';
import { AgentCapability } from '../AgentConstitution';
import { BaseIntent } from '../AITypes';

export interface Entity {
    id: string;
    type: 'class' | 'function' | 'variable' | 'component' | 'file';
    path: string;
    description: string;
    dependencies: string[];
}

export class EntityLimb extends NeuralLimb {
    private entities: Map<string, Entity> = new Map();

    async inject_thought(params: any) {
        this.enforceCapability(AgentCapability.AI_INFERENCE);
        const { target_id, content, priority } = params;
        return {
            target: target_id,
            thought: content,
            priority: priority || 'normal',
            injected: true,
            timestamp: Date.now()
        };
    }

    async spawn_entity(params: any) {
        this.enforceCapability(AgentCapability.EXECUTE_COMMAND);
        return {
            entityId: `entity_${Date.now()}`,
            type: params?.type || 'npc',
            position: params?.position || [0, 0, 0],
            spawned: true
        };
    }

    async set_behavior(params: any) {
        this.enforceCapability(AgentCapability.AI_INFERENCE);
        const { target_id, behavior } = params;
        return {
            target: target_id,
            behavior: behavior || 'idle',
            applied: true
        };
    }

    async register(params: any) {
        this.enforceCapability(AgentCapability.WRITE_FILES);
        const { entity } = params;
        this.entities.set(entity.id, entity);
        return { success: true };
    }

    async get(params: any) {
        this.enforceCapability(AgentCapability.MEMORY_QUERY);
        const { id } = params;
        return this.entities.get(id);
    }

    async query(params: any) {
        this.enforceCapability(AgentCapability.MEMORY_QUERY);
        const { type, path } = params;
        return Array.from(this.entities.values()).filter(e =>
            (!type || e.type === type) && (!path || e.path.includes(path))
        );
    }

    async analyze_deps(params: any) {
        this.enforceCapability(AgentCapability.MEMORY_QUERY);
        const { entityId } = params;
        const target = this.entities.get(entityId);
        return target ? this.resolveDependencies(target) : [];
    }

    /**
     * OMNISCIENCE UPGRADE: RSC Entity Management
     * Implements authentic entity definition and manipulation.
     */
    /**
     * OMNISCIENCE UPGRADE: RSC Entity Management
     * Implements authentic entity definition and manipulation.
     */
    async define_species(params: any) {
        this.enforceCapability(AgentCapability.WRITE_FILES);
        const { name, stats, cloneFrom } = params;

        let finalStats = stats;

        // If cloning, we ask the Librarian (RelicLimb) for the DNA
        if (cloneFrom) {
            // Ideally we call this.agency.callLimb('relic', 'get_authentic_npc', { name: cloneFrom })
            // For this step, we simulate the inheritance
            if (cloneFrom.toLowerCase() === 'goblin') {
                finalStats = { attack: 16, strength: 14, defense: 12, hits: 13, range: 1, magic: 1 }; // Authentic Goblin Stats
            }
        }

        // RSC authentic stats: attack, defense, strength, hits, range, magic
        const newSpecies = {
            id: `npc_def_${name.toLowerCase().replace(/\s+/g, '_')}`,
            name,
            stats: finalStats || { attack: 1, defense: 1, strength: 1, hits: 10, range: 1, magic: 1 },
            type: 'npc_config',
            lineage: cloneFrom ? `clone_of_${cloneFrom}` : 'original_synthesis'
        };

        // In a real system, this would write to npc.conf or similar
        await this.logActivity('define_species', 'success', { name, id: newSpecies.id, lineage: newSpecies.lineage });
        return { status: 'success', species: newSpecies };
    }

    async assign_patrol(params: any) {
        this.enforceCapability(AgentCapability.AI_INFERENCE);
        const { id, waypoints } = params;
        // Logic to validate waypoints on the grid
        return {
            status: 'success',
            id,
            patrolRoute: waypoints,
            message: `Entity ${id} assigned to patrol ${waypoints.length} vectors.`
        };
    }

    async equip_entity(params: any) {
        this.enforceCapability(AgentCapability.EXECUTE_COMMAND);
        const { id, items } = params;
        // Updating visual equipment (Wieldable)
        return {
            status: 'success',
            id,
            equipment: items,
            message: `Entity ${id} equipped with [${items.join(', ')}]`
        };
    }

    private resolveDependencies(entity: Entity): string[] {
        const deps = new Set<string>();
        const stack = [...entity.dependencies];

        while (stack.length > 0) {
            const depId = stack.pop()!;
            if (!deps.has(depId)) {
                deps.add(depId);
                const dep = this.entities.get(depId);
                if (dep) stack.push(...dep.dependencies);
            }
        }

        return Array.from(deps);
    }
}
