import{V as o}from"./VectorMemory-K7lUyAEt.js";class a{vectorMemory;env;constructor(e){this.env=e,this.vectorMemory=new o(e)}async indexCodebase(e){if(!this.env.AI||!this.env.VECTOR_INDEX)return console.log("[IntelRegistry] Proxying codebase indexing to agent..."),(await fetch("/api/session/default/intel/index-codebase",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({files:e})})).json();console.log(`[IntelRegistry] Indexing ${e.length} files...`);for(const t of e)await this.vectorMemory.upsertSnippet({id:`code_${btoa(t.path)}`,text:t.content,metadata:{type:"code",path:t.path,indexedAt:Date.now()}});return{status:"success",IndexedCount:e.length}}async indexAsset(e,t,n){if(!this.env.AI||!this.env.VECTOR_INDEX){console.warn("[IntelRegistry] Asset indexing requires direct bindings or a specialized proxy endpoint.");return}await this.vectorMemory.upsertSnippet({id:`asset_${e}`,text:t,metadata:{type:"asset",assetId:e,tags:n,indexedAt:Date.now()}})}async semanticSearch(e,t){if(!this.env.AI||!this.env.VECTOR_INDEX)return console.log("[IntelRegistry] Proxying semantic search to agent..."),(await fetch(`/api/session/default/intel/search?q=${encodeURIComponent(e)}${t?`&type=${t}`:""}`)).json();const n=await this.vectorMemory.queryKnowledge(e,5);return t?n.filter(s=>s.metadata?.type===t):n}}export{a as IntelRegistry};
