import{E as pt,G as mt,H as gt,b as bt,R as vt,V as xt}from"./Stage-CQNCdJUw.js";import{d as K}from"./GLTFLoader-Dr6w83BU.js";import{G as wt,t as jt}from"./GLTFLoader-Dr6w83BU.js";import{am as X,ap as Y,o as B,p as G,x as z,aw as I,G as Q,ax as R,n as O,ay as S,az as $,aA as N,aB as T,h as k}from"./three.module-DqfR4SX2.js";import"./main-DTuUJYgM.js";import"./constants-CPtoviZ5.js";import"./with-selector-kFzSnDwm.js";class ht extends X{constructor(s){super(s)}load(s,e,n,t){const r=this,l=new Y(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(s,function(v){try{e(r.parse(v))}catch(w){t?t(w):console.error(w),r.manager.itemError(s)}},n,t)}parse(s){function e(f){const c=new DataView(f),h=32/8*3+32/8*3*3+16/8,d=c.getUint32(80,!0);if(80+32/8+d*h===c.byteLength)return!0;const i=[115,111,108,105,100];for(let m=0;m<5;m++)if(n(i,c,m))return!1;return!0}function n(f,c,h){for(let d=0,o=f.length;d<o;d++)if(f[d]!==c.getUint8(h+d,!1))return!1;return!0}function t(f){const c=new DataView(f),h=c.getUint32(80,!0);let d,o,i,m=!1,b,g,x,p,u;for(let a=0;a<70;a++)c.getUint32(a,!1)==1129270351&&c.getUint8(a+4)==82&&c.getUint8(a+5)==61&&(m=!0,b=new Float32Array(h*3*3),g=c.getUint8(a+6)/255,x=c.getUint8(a+7)/255,p=c.getUint8(a+8)/255,u=c.getUint8(a+9)/255);const F=84,L=50,V=new B,j=new Float32Array(h*3*3),C=new Float32Array(h*3*3);for(let a=0;a<h;a++){const y=F+a*L,P=c.getFloat32(y,!0),E=c.getFloat32(y+4,!0),Z=c.getFloat32(y+8,!0);if(m){const U=c.getUint16(y+48,!0);(U&32768)===0?(d=(U&31)/31,o=(U>>5&31)/31,i=(U>>10&31)/31):(d=g,o=x,i=p)}for(let U=1;U<=3;U++){const D=y+U*12,_=a*3*3+(U-1)*3;j[_]=c.getFloat32(D,!0),j[_+1]=c.getFloat32(D+4,!0),j[_+2]=c.getFloat32(D+8,!0),C[_]=P,C[_+1]=E,C[_+2]=Z,m&&(b[_]=d,b[_+1]=o,b[_+2]=i)}}return V.setAttribute("position",new G(j,3)),V.setAttribute("normal",new G(C,3)),m&&(V.setAttribute("color",new G(b,3)),V.hasColors=!0,V.alpha=u),V}function r(f){const c=new B,h=/solid([\s\S]*?)endsolid/g,d=/facet([\s\S]*?)endfacet/g;let o=0;const i=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,m=new RegExp("vertex"+i+i+i,"g"),b=new RegExp("normal"+i+i+i,"g"),g=[],x=[],p=new z;let u,F=0,L=0,V=0;for(;(u=h.exec(f))!==null;){L=V;const j=u[0];for(;(u=d.exec(j))!==null;){let y=0,P=0;const E=u[0];for(;(u=b.exec(E))!==null;)p.x=parseFloat(u[1]),p.y=parseFloat(u[2]),p.z=parseFloat(u[3]),P++;for(;(u=m.exec(E))!==null;)g.push(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3])),x.push(p.x,p.y,p.z),y++,V++;P!==1&&console.error("THREE.STLLoader: Something isn't right with the normal of face number "+o),y!==3&&console.error("THREE.STLLoader: Something isn't right with the vertices of face number "+o),o++}const C=L,a=V-L;c.addGroup(C,a,F),F++}return c.setAttribute("position",new I(g,3)),c.setAttribute("normal",new I(x,3)),c}function l(f){return typeof f!="string"?K(new Uint8Array(f)):f}function v(f){if(typeof f=="string"){const c=new Uint8Array(f.length);for(let h=0;h<f.length;h++)c[h]=f.charCodeAt(h)&255;return c.buffer||c}else return f}const w=v(s);return e(w)?t(w):r(l(s))}}const tt=/^[og]\s*(.+)?/,et=/^mtllib /,st=/^usemtl /,rt=/^usemap /,q=new z,H=new z,J=new z,W=new z,A=new z;function nt(){const M={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=e!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,r){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const v={index:this.materials.length,name:t||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(w){const f={index:typeof w=="number"?w:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return f.clone=this.clone.bind(f),f}};return this.materials.push(v),v},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),t&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return t&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},n&&n.name&&typeof n.clone=="function"){const t=n.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,e){const n=parseInt(s,10);return(n>=0?n-1:n+e/3)*3},parseNormalIndex:function(s,e){const n=parseInt(s,10);return(n>=0?n-1:n+e/3)*3},parseUVIndex:function(s,e){const n=parseInt(s,10);return(n>=0?n-1:n+e/2)*2},addVertex:function(s,e,n){const t=this.vertices,r=this.object.geometry.vertices;r.push(t[s+0],t[s+1],t[s+2]),r.push(t[e+0],t[e+1],t[e+2]),r.push(t[n+0],t[n+1],t[n+2])},addVertexPoint:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addVertexLine:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addNormal:function(s,e,n){const t=this.normals,r=this.object.geometry.normals;r.push(t[s+0],t[s+1],t[s+2]),r.push(t[e+0],t[e+1],t[e+2]),r.push(t[n+0],t[n+1],t[n+2])},addFaceNormal:function(s,e,n){const t=this.vertices,r=this.object.geometry.normals;q.fromArray(t,s),H.fromArray(t,e),J.fromArray(t,n),A.subVectors(J,H),W.subVectors(q,H),A.cross(W),A.normalize(),r.push(A.x,A.y,A.z),r.push(A.x,A.y,A.z),r.push(A.x,A.y,A.z)},addColor:function(s,e,n){const t=this.colors,r=this.object.geometry.colors;t[s]!==void 0&&r.push(t[s+0],t[s+1],t[s+2]),t[e]!==void 0&&r.push(t[e+0],t[e+1],t[e+2]),t[n]!==void 0&&r.push(t[n+0],t[n+1],t[n+2])},addUV:function(s,e,n){const t=this.uvs,r=this.object.geometry.uvs;r.push(t[s+0],t[s+1]),r.push(t[e+0],t[e+1]),r.push(t[n+0],t[n+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const e=this.uvs;this.object.geometry.uvs.push(e[s+0],e[s+1])},addFace:function(s,e,n,t,r,l,v,w,f){const c=this.vertices.length;let h=this.parseVertexIndex(s,c),d=this.parseVertexIndex(e,c),o=this.parseVertexIndex(n,c);if(this.addVertex(h,d,o),this.addColor(h,d,o),v!==void 0&&v!==""){const i=this.normals.length;h=this.parseNormalIndex(v,i),d=this.parseNormalIndex(w,i),o=this.parseNormalIndex(f,i),this.addNormal(h,d,o)}else this.addFaceNormal(h,d,o);if(t!==void 0&&t!==""){const i=this.uvs.length;h=this.parseUVIndex(t,i),d=this.parseUVIndex(r,i),o=this.parseUVIndex(l,i),this.addUV(h,d,o),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const e=this.vertices.length;for(let n=0,t=s.length;n<t;n++){const r=this.parseVertexIndex(s[n],e);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(s,e){this.object.geometry.type="Line";const n=this.vertices.length,t=this.uvs.length;for(let r=0,l=s.length;r<l;r++)this.addVertexLine(this.parseVertexIndex(s[r],n));for(let r=0,l=e.length;r<l;r++)this.addUVLine(this.parseUVIndex(e[r],t))}};return M.startObject("",!1),M}class ut extends X{constructor(s){super(s),this.materials=null}load(s,e,n,t){const r=this,l=new Y(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(s,function(v){try{e(r.parse(v))}catch(w){t?t(w):console.error(w),r.manager.itemError(s)}},n,t)}setMaterials(s){return this.materials=s,this}parse(s){const e=new nt;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const n=s.split(`
`);let t="",r="",l=0,v=[];const w=typeof"".trimLeft=="function";for(let h=0,d=n.length;h<d;h++)if(t=n[h],t=w?t.trimLeft():t.trim(),l=t.length,l!==0&&(r=t.charAt(0),r!=="#"))if(r==="v"){const o=t.split(/\s+/);switch(o[0]){case"v":e.vertices.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])),o.length>=7?e.colors.push(parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6])):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));break;case"vt":e.uvs.push(parseFloat(o[1]),parseFloat(o[2]));break}}else if(r==="f"){const i=t.substr(1).trim().split(/\s+/),m=[];for(let g=0,x=i.length;g<x;g++){const p=i[g];if(p.length>0){const u=p.split("/");m.push(u)}}const b=m[0];for(let g=1,x=m.length-1;g<x;g++){const p=m[g],u=m[g+1];e.addFace(b[0],p[0],u[0],b[1],p[1],u[1],b[2],p[2],u[2])}}else if(r==="l"){const o=t.substring(1).trim().split(" ");let i=[];const m=[];if(t.indexOf("/")===-1)i=o;else for(let b=0,g=o.length;b<g;b++){const x=o[b].split("/");x[0]!==""&&i.push(x[0]),x[1]!==""&&m.push(x[1])}e.addLineGeometry(i,m)}else if(r==="p"){const i=t.substr(1).trim().split(" ");e.addPointGeometry(i)}else if((v=tt.exec(t))!==null){const o=(" "+v[0].substr(1).trim()).substr(1);e.startObject(o)}else if(st.test(t))e.object.startMaterial(t.substring(7).trim(),e.materialLibraries);else if(et.test(t))e.materialLibraries.push(t.substring(7).trim());else if(rt.test(t))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(r==="s"){if(v=t.split(" "),v.length>1){const i=v[1].trim().toLowerCase();e.object.smooth=i!=="0"&&i!=="off"}else e.object.smooth=!0;const o=e.object.currentMaterial();o&&(o.smooth=e.object.smooth)}else{if(t==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+t+'"')}e.finalize();const f=new Q;if(f.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let h=0,d=e.objects.length;h<d;h++){const o=e.objects[h],i=o.geometry,m=o.materials,b=i.type==="Line",g=i.type==="Points";let x=!1;if(i.vertices.length===0)continue;const p=new B;p.setAttribute("position",new I(i.vertices,3)),i.normals.length>0&&p.setAttribute("normal",new I(i.normals,3)),i.colors.length>0&&(x=!0,p.setAttribute("color",new I(i.colors,3))),i.hasUVIndices===!0&&p.setAttribute("uv",new I(i.uvs,2));const u=[];for(let L=0,V=m.length;L<V;L++){const j=m[L],C=j.name+"_"+j.smooth+"_"+x;let a=e.materials[C];if(this.materials!==null){if(a=this.materials.create(j.name),b&&a&&!(a instanceof R)){const y=new R;O.prototype.copy.call(y,a),y.color.copy(a.color),a=y}else if(g&&a&&!(a instanceof S)){const y=new S({size:10,sizeAttenuation:!1});O.prototype.copy.call(y,a),y.color.copy(a.color),y.map=a.map,a=y}}a===void 0&&(b?a=new R:g?a=new S({size:1,sizeAttenuation:!1}):a=new $,a.name=j.name,a.flatShading=!j.smooth,a.vertexColors=x,e.materials[C]=a),u.push(a)}let F;if(u.length>1){for(let L=0,V=m.length;L<V;L++){const j=m[L];p.addGroup(j.groupStart,j.groupCount,L)}b?F=new N(p,u):g?F=new T(p,u):F=new k(p,u)}else b?F=new N(p,u[0]):g?F=new T(p,u[0]):F=new k(p,u[0]);F.name=o.name,f.add(F)}else if(e.vertices.length>0){const h=new S({size:1,sizeAttenuation:!1}),d=new B;d.setAttribute("position",new I(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(d.setAttribute("color",new I(e.colors,3)),h.vertexColors=!0);const o=new T(d,h);f.add(o)}return f}}export{pt as EXRLoader,wt as GLTFLoader,mt as GroundProjectedEnv,gt as HorizontalBlurShader,ut as OBJLoader,bt as OrbitControls,vt as RGBELoader,ht as STLLoader,xt as VerticalBlurShader,jt as toTrianglesDrawMode};
