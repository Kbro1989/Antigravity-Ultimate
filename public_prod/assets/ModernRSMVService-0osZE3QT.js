import{C as g,c as o,u as w,i as p,E as h,T as m,R as b,p as y}from"./enginecache-CxS5uUsY.js";import{B as l,l as d}from"./main-Cde5WehW.js";import{G as C}from"./GLTFLoader-ggi2ZHwC.js";import"./three.module-aN59MUBe.js";import"../src/services/rsmv/clientscript/index.ts";import"../src/services/rsmv/clientscript/interpreter.ts";import"./constants-DucYOER3.js";class k extends g{indices=new Map;dbfiles={};worker;msgidcounter=1;callbacks=new Map;timestamp=new Date;constructor(){super(),this.worker=new Worker(new URL("/assets/sqlitewasmworker-Cx_wmnIN.js",import.meta.url)),this.worker.onmessage=e=>{let t=this.callbacks.get(e.data.id);if(e.data.error){if(t){let a=e.data.error;t.reqpacket.type=="getfile"?a+=`
 in getfile ${t.reqpacket.major}.${t.reqpacket.minor}`:t.reqpacket.type=="getindex"?a+=`
 in getindex ${t.reqpacket.major}`:a+=`
 in other ${t.reqpacket.type}`,t.reject(new Error(a))}}else t?.resolve(e.data.packet);this.callbacks.delete(e.data.id)}}getCacheMeta(){return{name:"sqlitewasm",descr:"Direclty loads NXT cache files from the disk, in browser compatible environment.",timestamp:this.timestamp}}async generateRootIndex(){console.log("using generated cache index file meta, crc size and version missing");let e=[];for(let t of Object.keys(this.dbfiles)){let a=t.match(/js5-(\d+)\.jcache$/);a&&(e[Number(a[1])]={major:o.index,minor:+a[1],crc:0,size:0,subindexcount:1,subindices:[0],subnames:null,name:null,version:0,uncompressed_crc:0,uncompressed_size:0})}return e}sendWorker(e){let t=this.msgidcounter++;return this.worker.postMessage({id:t,packet:e}),new Promise((a,s)=>this.callbacks.set(t,{resolve:a,reject:s,reqpacket:e}))}giveBlobs(e){Object.assign(this.dbfiles,e),this.sendWorker({type:"blobs",blobs:e})}async giveFsDirectory(e){let t={};if(await e.queryPermission()!="granted")return console.log("tried to open cache without permission"),null;for await(let a of e.values())a.kind=="file"&&(t[a.name]=await a.getFile());this.giveBlobs(t)}async getFile(e,t,a){if(e==o.index)return this.getIndexFile(t);let s=await this.sendWorker({type:"getfile",major:e,minor:t,crc:a});return l.from(s.buffer,s.byteOffset,s.byteLength)}async putFile(e,t,a){await this.sendWorker({type:"putfile",major:e,minor:t,data:a})}async saveCache(e){let t=await this.sendWorker({type:"save",major:e});return l.from(t.buffer,t.byteOffset,t.byteLength)}async getFileArchive(e){let t=await this.getFile(e.major,e.minor,e.crc);return w(t,e.subindices,e.subnames)}async getCacheIndex(e){if(e==o.index)return this.generateRootIndex();let t=this.indices.get(e);return t||(t=this.getIndexFile(e).then(a=>p(e,a,this)),this.indices.set(e,t)),t}async getIndexFile(e){let t=await this.sendWorker({type:"getindex",major:e});return l.from(t.buffer,t.byteOffset,t.byteLength)}close(){this.worker.terminate()}}class j{constructor(e={}){this.config=e}engineCache=null;sceneCache=null;glbLoader=new C;wasmLoader=null;cachePath=null;async ensureInitialized(){this.wasmLoader||(this.wasmLoader=new k,this.wasmLoader.getBuildNr=()=>920)}async linkLocalCache(e="C:\\ProgramData\\Jagex\\RuneScape"){await this.ensureInitialized();const t=await d.listDirectory(e);if(!t?.success||!t.files)return console.error(`RSMV: Failed to read cache at ${e}`),!1;const a={};for(const s of t.files)if(s.name.endsWith(".jcache")){const i=await d.readLocalFile(s.path,!0);if(i.success&&i.content){const n=atob(i.content),c=new Uint8Array(n.length);for(let r=0;r<n.length;r++)c[r]=n.charCodeAt(r);a[s.name]=new Blob([c])}}return Object.keys(a).length===0?(console.warn("RSMV: No .jcache files found in the specified directory"),!1):(this.wasmLoader.giveBlobs(a),this.cachePath=e,this.engineCache=await h.create(this.wasmLoader),this.sceneCache=await m.create(this.engineCache),!0)}async loadModel(e){if(this.config.useGlbFirst&&this.config.glbBaseUrl)try{const i=`${this.config.glbBaseUrl}/model_${e}.glb`,n=await this.glbLoader.loadAsync(i);return{id:e,name:`model:${e}`,scene:n.scene,metadata:n.userData}}catch{}if(!this.sceneCache)throw new Error("RSMV: Not initialized or cache not linked.");const t=[{modelid:e,mods:{}}],a=new b(this.sceneCache,t,`model:${e}`),s=await a.model;return{id:e,name:a.rootnode.name,scene:a.rootnode,metadata:s.modeldata}}async loadMap(e){throw new Error("Modern map loading not implemented.")}async loadAudio(e){throw new Error("Modern audio loading not implemented.")}async loadUI(e){throw new Error("Modern UI loading not implemented.")}async getItems(){return[]}async loadAvatar(e){throw new Error("Method not implemented.")}dispose(){this.engineCache?.close(),this.sceneCache=null,this.engineCache=null,this.wasmLoader=null}async linkDroppedCache(e){return await this.ensureInitialized(),this.wasmLoader.giveBlobs(e),this.engineCache=await h.create(this.wasmLoader),this.sceneCache=await m.create(this.engineCache),!0}async saveModel(e,t){const a=this.config.stagedPath||this.cachePath;if(!this.engineCache||!this.wasmLoader||!a)return!1;try{const s=y.models.write(t);await this.wasmLoader.putFile(o.models,e,new Uint8Array(s));const i=await this.wasmLoader.saveCache(o.models),n=`js5-${o.models}.jcache`,c=`${a}\\${n}`,r=btoa(String.fromCharCode(...new Uint8Array(i))),u=await d.writeLocalFile(c,r,!0);return console.log(`[RSMV] Model ${e} saved to ${this.config.stagedPath?"STAGING":"CACHE"}: ${c}`),u.success}catch(s){return console.error(`RSMV: Save model ${e} failed:`,s),!1}}getEngineCache(){return this.engineCache}getSceneCache(){return this.sceneCache}}export{j as ModernRSMVService};
